use std::{env, fs, io::Write, path::PathBuf};

fn sanitize_ident(raw: &str) -> String {
    let out: String = raw
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '_' {
                c.to_ascii_lowercase()
            } else {
                '_'
            }
        })
        .collect();

    if out.is_empty() {
        "case".to_string()
    } else {
        out
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let snapshot_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?)
        .join("tests")
        .join("snapshot");
    println!("cargo:rerun-if-changed={}", snapshot_dir.display());

    let mut cases = Vec::new();

    if snapshot_dir.exists() {
        for entry in fs::read_dir(&snapshot_dir)? {
            let entry = entry?;
            let path = entry.path();
            if !path.is_file() {
                continue;
            }
            let name = path
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or_default();
            if !(name.starts_with("input_") && name.ends_with(".rs")) {
                continue;
            }
            let key = name.trim_start_matches("input_").trim_end_matches(".rs");
            let output_name = format!("output_{}.qasm", key);
            let expected_path = snapshot_dir.join(&output_name);
            println!("cargo:rerun-if-changed={}", path.display());
            if expected_path.exists() {
                println!("cargo:rerun-if-changed={}", expected_path.display());
            }
            cases.push((key.to_string(), path, expected_path));
        }
    }

    let dest = PathBuf::from(env::var("OUT_DIR")?).join("snapshot_cases.rs");
    let mut f = fs::File::create(&dest)?;

    writeln!(f, "// @generated by build.rs; do not edit.")?;
    writeln!(
        f,
        "pub struct Case {{ pub name: &'static str, pub expected: &'static str, pub build: fn() -> openqasm3::ast::Program }}"
    )?;
    for (key, input_path, _expected_path) in &cases {
        let mod_name = format!("case_{}", sanitize_ident(key));
        writeln!(
            f,
            "mod {mod_name} {{ include!(r#\"{}\"#); }}",
            input_path.display()
        )?;
    }
    writeln!(f, "pub static CASES: &[Case] = &[")?;
    for (key, _input_path, expected_path) in &cases {
        let mod_name = format!("case_{}", sanitize_ident(key));
        writeln!(
            f,
            "    Case {{ name: r#\"{}\"#, expected: r#\"{}\"#, build: {mod_name}::build }},",
            key,
            expected_path.display()
        )?;
    }
    writeln!(f, "];")?;

    Ok(())
}
